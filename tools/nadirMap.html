<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Nadir map</title>
</head>
<body>
  <progress id="load" ></progress><br>
  <progress id="draw" max="1" value="0"></progress><br>
  <canvas id="canvas"></canvas><br>
  <style>
    progress{
      width: 600px;
    }
  </style>
  <script>
    var mask = new OffscreenCanvas(1, 1);
    var canvas = document.querySelector('#canvas');
    var loadBar = document.querySelector('#load');
    var drawBar = document.querySelector('#draw');
    var ctx = canvas.getContext('2d');
    var mctx = mask.getContext('2d');

    var scale = opener.camera.scale//*0.42;

    var panorams = opener.state.current.panorams.filter(function(pano){
        return pano.floor == opener.floors.active
    })
    var images = {};

    var loadedImages = 0;

    var onImageLoad = function(id){
      images[id] = this;
      loadBar.value = ++loadedImages;
      loadBar.max = panorams.length;

      if(loadedImages==panorams.length){
        rady();
      }
    }

    panorams.forEach(function(pano){
      var img = new Image();
      img.src = [
        opener.opener.location.origin,
        opener.opener.location.pathname,
        'panorams',
        pano.id,
        'thumbnail/uwn.jpg'
      ].join('/');
      img.onload = onImageLoad.bind(img, pano.id)
    })


    function drawLayer(step){
      panorams.forEach(function(pano){
        var img = images[pano.id]
        var x = pano.x*scale-xmin*scale;
        var y = pano.y*scale-ymin*scale
        var d = pano.heightFromFloor*2*scale*3
        var r = d/2
        mask.width = mask.height = d;
        mctx.globalCompositeOperation="source-over";
        mctx.beginPath();
        mctx.arc(r, r, r*step, 0, 2 * Math.PI, false);
        if(step!=1){
          var gradient = ctx.createRadialGradient(r,r,0,r,r,r*step);
          gradient.addColorStop(0, 'black');
          gradient.addColorStop(.3, 'black');
          gradient.addColorStop(1, 'rgba(0,0,0,0)');
          mctx.fillStyle = gradient;
          mctx.fill();
        }else{
          mctx.fillStyle = 'black';
          mctx.fill();
        }
       
        
        mctx.globalCompositeOperation="source-in";
        mctx.translate(r, r);
        mctx.rotate(opener.THREE.Math.degToRad(pano.heading));
        mctx.drawImage(img, -r, -r, d, d);
        mctx.rotate(-opener.THREE.Math.degToRad(pano.heading));
        mctx.translate(-r, -r);
        ctx.translate(x, y);
        ctx.drawImage(mask, -r, -r, d, d);
        ctx.translate(-x, -y);
      })
    }

    var xmin, xmax, ymin, ymax, width, height;

    function rady(){ 
      var size = 154*2*3
      xmin = Math.min(...opener.state.current.panorams.map(item => item.x))-size/2;
      xmax = Math.max(...opener.state.current.panorams.map(item => item.x));
      ymin = Math.min(...opener.state.current.panorams.map(item => item.y))-size/2;
      ymax = Math.max(...opener.state.current.panorams.map(item => item.y));

      width = Math.abs(xmin - xmax)+size/2;
      height = Math.abs(ymin - ymax)+size/2;



      canvas.width = width*scale;
      canvas.height = height*scale;

      render();
    }

    var r = 1;
    function render(){
      var min = 0.05
      var step = 0.025
      if(r>=min){
        drawLayer(r);
        r-=step;
      }
      drawBar.value = 1-r+min;
      window.requestAnimationFrame(render)
    }

  </script>
</body>
</html>